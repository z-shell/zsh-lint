# -*- mode: zsh; sh-indentation: 2; indent-tabs-mode: nil; sh-basic-offset: 2; -*-
# vim: ft=zsh sw=2 ts=2 et
#
# Copyright (c) 2021 Salvydas Lukosius
#
# Input:
# $1 - text to process
#
# Output:
# ZSHLINT_PB_WORDS - split of "$1" into shell words; array
# ZSHLINT_PB_WORDS_BEGINNINGS - indexes of first letters of corresponding words in ZSHLINT_PB_WORDS
# ZSHLINT_PB_SPACES - white spaces before corresponding words in ZSHLINT_PB_WORDS
# ZSHLINT_PB_ALL - spaces and words, together
#

emulate -LR zsh
setopt typesetsilent extendedglob noshortloops

local -a mbegin mend match
local MATCH; integer MBEGIN MEND

local buf="$1"
local len="${#buf}"

# All output variables are either overwritten or cleared
ZSHLINT_PB_WORDS=( "${(Z+cn+)buf}" )
ZSHLINT_PB_SPACES=()
ZSHLINT_PB_WORDS_BEGINNINGS=()
ZSHLINT_PB_ALL=()

# (Z+n+) will return 1 element for buf that is empty or only whitespace
if [[ "$buf" = ( |$'\t')# ]]; then
  ZSHLINT_PB_WORDS=()
  integer nwords=0
else
  integer nwords="${#ZSHLINT_PB_WORDS}"
fi

/zsh-lint-dbg "Processing #$nwords tokens"

# Remove ZSHLINT_PB_WORDS one by one, counting characters,
# computing beginning of each word, to find
# place to break the word into 2 halves (for
# complete_in_word option)

local i word wordlen text text_len text2 text2_len tmp_buf search='\\'$'\n' search2='\\('$'\n|(#e))'
integer bslen start found found2
integer char_count=0

for (( i=1; i<=nwords; i++ )); do
  # Remove spurious space generated by Z-flag when
  # input is an unbound '$(' (happens with zsh < 5.1)
  # and also real spaces gathered by an unbound '$(',
  # to handle them in a way normal to this loop
  ZSHLINT_PB_WORDS[i]="${ZSHLINT_PB_WORDS[i]%% ##}"
  word="${ZSHLINT_PB_WORDS[i]}"
  wordlen="${#word}"
  # Remove white spaces
  buf="${buf##(#m)[^$word[1]]#}"
  # Detect text modification via backslash at end of line.
  # When in string, such backslash is removed and lines
  # concatenated into single token
  start=0
  # +2 to detect a trailing \$'\n' removal in case of unquoted
  # trailing backslash and then an empty line
  bslen=wordlen+2
  tmp_buf="$word"
  while (( 1 )); do
    # start+1+bslen-1 - position 1 shifted by `start',
    # follows text long for `bslen' characters
    text="${buf[start+1,start+1+bslen-1]}"
    text_len="${#text}"
    found="${text[(i)$search]}"
    # Found \$'n' ?
    (( found && found <= text_len )) && {
      text2="${tmp_buf[start+1,start+1+bslen-1]}"
      text2_len="${#text2}"
      found2="${text2[(i)${~search2}]}"
      # The \$'\n' not missing?
      if (( found2 == 0 || found2 > text2_len || found2 != found )); then
        /zsh-lint-dbg "Complex zshrc construct [len:$text_len]: $text"
        # +2 added before this loop to fully compensate
        # 2-characters long \$'\n'
        word="${buf[1,start+1+bslen-1]}"
        ZSHLINT_PB_WORDS[i]="$word"
        # Start is 0-based, so -1
        start+=found+2-1
        # After processing of single \$'\n' we should add 2
        # characters into the bslen, as the two extra chars
        # have been now detected.
        # Subtracting found+1 subtracts the \$'\n' that are
        # found:
        #  tttttFFttttt, bslen=12, found=6
        #         ttttt, correct bslen=12-7
        # Initial +2 added to wordlen constantly holds.
        bslen=bslen-(found+1)+2
      else
        /zsh-lint-dbg "False alarm for [len:$text2_len]: $text2"
        start+=found+2-1
        bslen=bslen-(found+1)+2
      fi
    } || {
      wordlen="${#word}"
      if [[ "$start" -gt 0 ]]; then
        /zsh-lint-dbg "Fixed expression [len:$wordlen]: $word"
        /zsh-lint-dbg ""
      fi
      break
    }
  done
  # In general, $buf can start with white spaces
  # We will not search for them, but instead for
  # leading character of current shell word,
  # negated. This is an ambition to completely
  # avoid character classes
  # Count them
  char_count=char_count+"${#MATCH}"
  # This is the beginning of current word
  ZSHLINT_PB_WORDS_BEGINNINGS[i]=$(( char_count + 1 ))
  # Remember the spaces
  ZSHLINT_PB_SPACES[i]="$MATCH"
  # Store full data
  ZSHLINT_PB_ALL+=( "$MATCH" "$word" )
  # Remove the word
  buf="${buf[wordlen+1,len]}"
done

# What's left in $buf can be only white spaces
ZSHLINT_PB_SPACES[i]="$buf"
ZSHLINT_PB_ALL+=( "$buf" )

return 0
